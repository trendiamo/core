var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _operationNames;

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import camelCase from 'lodash/camelCase';
import merge from 'lodash/merge';
import pluralize from 'pluralize';

import buildDataProvider from 'ra-data-graphql';
import { CREATE, DELETE, DELETE_MANY, GET_LIST, GET_MANY, GET_MANY_REFERENCE, GET_ONE, UPDATE, UPDATE_MANY } from 'react-admin';

import prismaBuildQuery from './buildQuery';

export var buildQuery = prismaBuildQuery;

var defaultOptions = {
  buildQuery: buildQuery,
  introspection: {
    operationNames: (_operationNames = {}, _defineProperty(_operationNames, GET_LIST, function (resource) {
      return '' + pluralize(camelCase(resource.name));
    }), _defineProperty(_operationNames, GET_ONE, function (resource) {
      return '' + camelCase(resource.name);
    }), _defineProperty(_operationNames, GET_MANY, function (resource) {
      return '' + pluralize(camelCase(resource.name));
    }), _defineProperty(_operationNames, GET_MANY_REFERENCE, function (resource) {
      return '' + pluralize(camelCase(resource.name));
    }), _defineProperty(_operationNames, CREATE, function (resource) {
      return 'create' + resource.name;
    }), _defineProperty(_operationNames, UPDATE, function (resource) {
      return 'update' + resource.name;
    }), _defineProperty(_operationNames, DELETE, function (resource) {
      return 'delete' + resource.name;
    }), _operationNames),
    exclude: undefined,
    include: undefined
  }
};

//TODO: Prisma supports batching (UPDATE_MANY, DELETE_MANY)
export default (function (options) {
  return buildDataProvider(merge({}, defaultOptions, options)).then(function (graphQLDataProvider) {
    return function (fetchType, resource, params) {
      // Temporary work-around until we make use of updateMany and deleteMany mutations
      if (fetchType === DELETE_MANY) {
        var ids = params.ids,
            otherParams = _objectWithoutProperties(params, ['ids']);

        return Promise.all(params.ids.map(function (id) {
          return graphQLDataProvider(DELETE, resource, _extends({
            id: id
          }, otherParams));
        })).then(function (results) {
          return { data: results.map(function (_ref) {
              var data = _ref.data;
              return data.id;
            }) };
        });
      }

      if (fetchType === UPDATE_MANY) {
        var _ids = params.ids,
            _otherParams = _objectWithoutProperties(params, ['ids']);

        return Promise.all(params.ids.map(function (id) {
          return graphQLDataProvider(UPDATE, resource, _extends({
            id: id
          }, _otherParams));
        })).then(function (results) {
          return { data: results.map(function (_ref2) {
              var data = _ref2.data;
              return data.id;
            }) };
        });
      }
      return graphQLDataProvider(fetchType, resource, params);
    };
  });
});