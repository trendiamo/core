var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { GET_LIST, GET_ONE, GET_MANY, GET_MANY_REFERENCE, CREATE, UPDATE, DELETE } from 'react-admin';

import isObject from 'lodash/isObject';

import getFinalType from './utils/getFinalType';
import { computeFieldsToAddRemoveUpdate } from './utils/computeAddRemoveUpdate';

import { PRISMA_CONNECT, PRISMA_DISCONNECT, PRISMA_UPDATE } from './constants/mutations';

//TODO: Object filter weren't tested yet
var buildGetListVariables = function buildGetListVariables(introspectionResults) {
  return function (resource, aorFetchType, params) {
    var filter = Object.keys(params.filter).reduce(function (acc, key) {
      if (key === 'ids') {
        return _extends({}, acc, { id_in: params.filter[key] });
      }

      if (Array.isArray(params.filter[key])) {
        var type = introspectionResults.types.find(function (t) {
          return t.name === resource.type.name + 'WhereInput';
        });
        var inputField = type.inputFields.find(function (t) {
          return t.name === key;
        });

        if (!!inputField) {
          return _extends({}, acc, _defineProperty({}, key, { id_in: params.filter[key] }));
        }
      }

      if (isObject(params.filter[key])) {
        var _type = introspectionResults.types.find(function (t) {
          return t.name === resource.type.name + 'WhereInput';
        });
        var filterSome = _type.inputFields.find(function (t) {
          return t.name === key + '_some';
        });

        if (filterSome) {
          var _filter = Object.keys(params.filter[key]).reduce(function (acc, k) {
            return _extends({}, acc, _defineProperty({}, k + '_in', params.filter[key][k]));
          }, {});
          return _extends({}, acc, _defineProperty({}, key + '_some', _filter));
        }
      }

      var parts = key.split('.');

      if (parts.length > 1) {
        if (parts[1] == 'id') {
          var _type2 = introspectionResults.types.find(function (t) {
            return t.name === resource.type.name + 'WhereInput';
          });
          var _filterSome = _type2.inputFields.find(function (t) {
            return t.name === parts[0] + '_some';
          });

          if (_filterSome) {
            return _extends({}, acc, _defineProperty({}, parts[0] + '_some', { id: params.filter[key] }));
          }

          return _extends({}, acc, _defineProperty({}, parts[0], { id: params.filter[key] }));
        }

        var resourceField = resource.type.fields.find(function (f) {
          return f.name === parts[0];
        });
        if (resourceField.type.name === 'Int') {
          return _extends({}, acc, _defineProperty({}, key, parseInt(params.filter[key])));
        }
        if (resourceField.type.name === 'Float') {
          return _extends({}, acc, _defineProperty({}, key, parseFloat(params.filter[key])));
        }
      }

      return _extends({}, acc, _defineProperty({}, key, params.filter[key]));
    }, {});

    return {
      skip: parseInt((params.pagination.page - 1) * params.pagination.perPage),
      first: parseInt(params.pagination.perPage),
      orderBy: params.sort.field + '_' + params.sort.order,
      where: filter
    };
  };
};

var findInputFieldForType = function findInputFieldForType(introspectionResults, typeName, field) {
  var type = introspectionResults.types.find(function (t) {
    return t.name === typeName;
  });

  if (!type) {
    return null;
  }

  var inputFieldType = type.inputFields.find(function (t) {
    return t.name === field;
  });

  return !!inputFieldType ? getFinalType(inputFieldType.type) : null;
};

var inputFieldExistsForType = function inputFieldExistsForType(introspectionResults, typeName, field) {
  return !!findInputFieldForType(introspectionResults, typeName, field);
};

var buildReferenceField = function buildReferenceField(_ref) {
  var inputArg = _ref.inputArg,
      introspectionResults = _ref.introspectionResults,
      typeName = _ref.typeName,
      field = _ref.field,
      mutationType = _ref.mutationType;

  var inputType = findInputFieldForType(introspectionResults, typeName, field);
  var mutationInputType = findInputFieldForType(introspectionResults, inputType.name, mutationType);

  return Object.keys(inputArg).reduce(function (acc, key) {
    return inputFieldExistsForType(introspectionResults, mutationInputType.name, key) ? _extends({}, acc, _defineProperty({}, key, inputArg[key])) : acc;
  }, {});
};

var buildUpdateVariables = function buildUpdateVariables(introspectionResults) {
  return function (resource, aorFetchType, params) {
    return Object.keys(params.data).reduce(function (acc, key) {
      if (Array.isArray(params.data[key])) {
        var _key;

        var inputType = findInputFieldForType(introspectionResults, resource.type.name + 'UpdateInput', key);

        if (!inputType) {
          return acc;
        }

        //TODO: Make connect, disconnect and update overridable
        //TODO: Make updates working

        var _computeFieldsToAddRe = computeFieldsToAddRemoveUpdate(params.previousData[key + 'Ids'], params.data[key + 'Ids']),
            fieldsToAdd = _computeFieldsToAddRe.fieldsToAdd,
            fieldsToRemove = _computeFieldsToAddRe.fieldsToRemove;

        return _extends({}, acc, {
          data: _extends({}, acc.data, _defineProperty({}, key, (_key = {}, _defineProperty(_key, PRISMA_CONNECT, fieldsToAdd), _defineProperty(_key, PRISMA_DISCONNECT, fieldsToRemove), _key)))
        });
      }

      if (isObject(params.data[key])) {
        var fieldsToUpdate = buildReferenceField({
          inputArg: params.data[key],
          introspectionResults: introspectionResults,
          typeName: resource.type.name + 'UpdateInput',
          field: key,
          mutationType: PRISMA_CONNECT
        });

        // If no fields in the object are valid, continue
        if (Object.keys(fieldsToUpdate).length === 0) {
          return acc;
        }

        // Else, connect the nodes
        return _extends({}, acc, { data: _extends({}, acc.data, _defineProperty({}, key, _defineProperty({}, PRISMA_CONNECT, _extends({}, fieldsToUpdate)))) });
      }

      // Put id field in a where object
      if (key === 'id' && params.data[key]) {
        return _extends({}, acc, {
          where: {
            id: params.data[key]
          }
        });
      }

      var type = introspectionResults.types.find(function (t) {
        return t.name === resource.type.name;
      });
      var isInField = type.fields.find(function (t) {
        return t.name === key;
      });

      if (!!isInField) {
        // Rest should be put in data object
        return _extends({}, acc, {
          data: _extends({}, acc.data, _defineProperty({}, key, params.data[key]))
        });
      }

      return acc;
    }, {});
  };
};

var buildCreateVariables = function buildCreateVariables(introspectionResults) {
  return function (resource, aorFetchType, params) {
    return Object.keys(params.data).reduce(function (acc, key) {
      if (Array.isArray(params.data[key])) {
        if (!inputFieldExistsForType(introspectionResults, resource.type.name + 'CreateInput', key)) {
          return acc;
        }

        return _extends({}, acc, {
          data: _extends({}, acc.data, _defineProperty({}, key, _defineProperty({}, PRISMA_CONNECT, params.data[key + 'Ids'].map(function (id) {
            return { id: id };
          }))))
        });
      }

      if (isObject(params.data[key])) {
        var fieldsToConnect = buildReferenceField({
          inputArg: params.data[key],
          introspectionResults: introspectionResults,
          typeName: resource.type.name + 'CreateInput',
          field: key,
          mutationType: PRISMA_CONNECT
        });

        // If no fields in the object are valid, continue
        if (Object.keys(fieldsToConnect).length === 0) {
          return acc;
        }

        // Else, connect the nodes
        return _extends({}, acc, { data: _extends({}, acc.data, _defineProperty({}, key, _defineProperty({}, PRISMA_CONNECT, _extends({}, fieldsToConnect)))) });
      }

      // Put id field in a where object
      if (key === 'id' && params.data[key]) {
        return _extends({}, acc, {
          where: {
            id: params.data[key]
          }
        });
      }

      var type = introspectionResults.types.find(function (t) {
        return t.name === resource.type.name;
      });
      var isInField = type.fields.find(function (t) {
        return t.name === key;
      });

      if (isInField) {
        // Rest should be put in data object
        return _extends({}, acc, {
          data: _extends({}, acc.data, _defineProperty({}, key, params.data[key]))
        });
      }

      return acc;
    }, {});
  };
};

export default (function (introspectionResults) {
  return function (resource, aorFetchType, params, queryType) {
    switch (aorFetchType) {
      case GET_LIST:
        {
          return buildGetListVariables(introspectionResults)(resource, aorFetchType, params, queryType);
        }
      case GET_MANY:
        return {
          where: { id_in: params.ids }
        };
      case GET_MANY_REFERENCE:
        {
          var parts = params.target.split('.');

          return {
            where: _defineProperty({}, parts[0], { id: params.id })
          };
        }
      case GET_ONE:
        return {
          where: { id: params.id }
        };
      case UPDATE:
        {
          return buildUpdateVariables(introspectionResults)(resource, aorFetchType, params);
        }

      case CREATE:
        {
          return buildCreateVariables(introspectionResults)(resource, aorFetchType, params);
        }

      case DELETE:
        return {
          where: { id: params.id }
        };
    }
  };
});